#!/usr/bin/env Rscript

# ============================================================
# Structural vs Amino Acid Phylogeny Comparison
#
# LEFT tree  : FoldMason structural guide tree (.nw)
# RIGHT tree : IQ-TREE amino acid ML consensus tree (.contree)
#
# Outputs:
#   - Tanglegram PNG
#   - Tree comparison metrics (RF + Entanglement)
#   - Session info for reproducibility
#
# Author: Casey Moyer
# ============================================================

suppressPackageStartupMessages({
  library(ape)
  library(phangorn)
  library(dendextend)
  library(viridisLite)
})

# ----------------------------
# 1 — Argument handling
# ----------------------------
args <- commandArgs(trailingOnly = TRUE)

if (length(args) >= 2) {
  tL_file <- args[1]
  tR_file <- args[2]
} else {
  tL_file <- "data/lysB_structural.nw"
  tR_file <- "data/lysB_AA_ML.contree"
}

# Output locations
dir.create("results", showWarnings = FALSE)

output_png  <- "results/AA_vs_Struct_tanglegram.png"
output_csv  <- "results/AA_vs_Struct_tree_metrics.csv"
output_sess <- "results/sessionInfo.txt"

# Adjustable parameter
h_rel <- 0.25  # relative cluster cut height (0–1)

# ----------------------------
# 2 — Read trees
# ----------------------------
cat("Reading trees...\n")

tL <- read.tree(tL_file)
tR <- read.tree(tR_file)

cat("Original tip counts:\n")
cat("  LEFT (struct):", length(tL$tip.label), "\n")
cat("  RIGHT (AA):   ", length(tR$tip.label), "\n")

# ----------------------------
# 3 — Retain shared taxa only
# ----------------------------
shared <- intersect(tL$tip.label, tR$tip.label)

if (length(shared) < 3) {
  stop("Insufficient shared taxa between trees.")
}

tL <- keep.tip(tL, shared)
tR <- keep.tip(tR, shared)

stopifnot(setequal(tL$tip.label, tR$tip.label))

cat("Shared tips:", length(shared), "\n")

# ----------------------------
# 4 — Root + resolve topology
# ----------------------------
tL <- midpoint(tL)
tR <- midpoint(tR)

if (!is.binary(tL)) tL <- multi2di(tL)
if (!is.binary(tR)) tR <- multi2di(tR)

tL <- ladderize(tL)
tR <- ladderize(tR)

# ----------------------------
# 5 — Convert to dendrograms
# ----------------------------
dL <- as.dendrogram(
  hclust(as.dist(cophenetic(tL)), method = "average")
)

dR <- as.dendrogram(
  hclust(as.dist(cophenetic(tR)), method = "average")
)

# ----------------------------
# 6 — Define clusters (LEFT tree)
# ----------------------------
maxh <- attr(dL, "height")
clL  <- cutree(dL, h = h_rel * maxh)

k    <- length(unique(clL))
pal  <- setNames(viridis(k), sort(unique(clL)))

# ----------------------------
# 7 — Color dendrograms
# ----------------------------
dL_col <- set(dL, "labels_col", pal[clL[labels(dL)]])
dR_col <- set(dR, "labels_col", pal[clL[labels(dR)]])

dL_col <- set(dL_col, "branches_col", "gray30")
dR_col <- set(dR_col, "branches_col", "gray30")

dL_col <- set(dL_col, "branches_lwd", 1)
dR_col <- set(dR_col, "branches_lwd", 1)

# ----------------------------
# 8 — Untangle trees
# ----------------------------
set.seed(1)
unt <- untangle(dL_col, dR_col, method = "step2side")

dL_col <- unt[[1]]
dR_col <- unt[[2]]

line_cols <- pal[clL[labels(dL_col)]]

# ----------------------------
# 9 — Plot tanglegram
# ----------------------------
png(
  filename = output_png,
  width = 12,
  height = 9,
  units = "in",
  res = 300
)

tanglegram(
  dL_col,
  dR_col,
  lab.cex = 1,
  margin_inner = 5,
  highlight_distinct_edges = FALSE,
  common_subtrees_color_lines = FALSE,
  lwd = 1,
  color_lines = line_cols
)

dev.off()

cat("Wrote:", output_png, "\n")

# ----------------------------
# 10 — Tree comparison metrics
# ----------------------------
rf <- RF.dist(unroot(tL), unroot(tR), normalize = TRUE)
ent <- entanglement(dL_col, dR_col)

cat("Normalized RF distance:", rf, "\n")
cat("Entanglement:", ent, "\n")

metrics_df <- data.frame(
  metric = c("Normalized_RF", "Entanglement"),
  value  = c(rf, ent)
)

write.csv(metrics_df, output_csv, row.names = FALSE)

cat("Wrote:", output_csv, "\n")

# ----------------------------
# 11 — Save session info
# ----------------------------
writeLines(capture.output(sessionInfo()), output_sess)
cat("Wrote:", output_sess, "\n")

cat("Analysis complete.\n")
